var documenterSearchIndex = {"docs":
[{"location":"types/masking/#Masking","page":"Masking","title":"Masking","text":"","category":"section"},{"location":"types/masking/","page":"Masking","title":"Masking","text":"CurrentModule = CryptoSideChannel.Masking","category":"page"},{"location":"types/masking/","page":"Masking","title":"Masking","text":"Masked","category":"page"},{"location":"types/masking/#CryptoSideChannel.Masking.Masked","page":"Masking","title":"CryptoSideChannel.Masking.Masked","text":"struct Masked{M, T1, T2}\n    val::T1\n    mask::T2\nend\n\nThe Masked datatype behaves like an integer, but splits its internal value into two shares. Hence, the plain value held by a Masked type should not be observable in memory\n\nwarning: Warning\nThe above statement holds only in theory. See the article on problems with high-level software masking for details on this problem.\n\nType Arguments\n\nM is the way in which the underlying value is masked. M can be either Boolean or Arithmetic, representing boolean masking or arithmetic masking, respectively.\nT1 is the type of the first share. This can be any integer-like type: A primitive integer, a GenericLog type, or another Masked type for higher-order masking.\nT2 is the type of the second share. This should always be either a primitive integer type, or a GenericLog type.\n\n\n\n\n\n","category":"type"},{"location":"types/masking/","page":"Masking","title":"Masking","text":"It may be useful to extract the content of a Masked type, for example at the end of a cryptographic calculation.","category":"page"},{"location":"types/masking/","page":"Masking","title":"Masking","text":"unmask","category":"page"},{"location":"types/masking/#CryptoSideChannel.Masking.unmask","page":"Masking","title":"CryptoSideChannel.Masking.unmask","text":"unmask(a::Masked)\n\nUnmask the contained integer by calculating val ⊻ mask, or val + mask respectively.\n\nNote that this function is unsafe with respect to side-channels. After calling this function, the data will no longer be split into two shares. Thus, this method should only be called at the end of a cryptographic algorithm to extract the final result.\n\n\n\n\n\n","category":"function"},{"location":"types/masking/#Masking-Types","page":"Masking","title":"Masking Types","text":"","category":"section"},{"location":"types/masking/#boolean_masking","page":"Masking","title":"Boolean Masking","text":"","category":"section"},{"location":"types/masking/","page":"Masking","title":"Masking","text":"BooleanMask","category":"page"},{"location":"types/masking/#CryptoSideChannel.Masking.BooleanMask","page":"Masking","title":"CryptoSideChannel.Masking.BooleanMask","text":"BooleanMask(v)\n\nCreate a masked integer holding value v. Internally, v will be stored in two shares, val and mask, such that v = val ⊻ mask. The latter condition is an invariant of this datatype.\n\nIt should always be the case that mask is a primitive type, i.e. of the type Integer or GenericLog. If higher-order masking is desired, val can be of the type Masked.\n\n\n\n\n\n","category":"function"},{"location":"types/masking/#arithmetic_masking","page":"Masking","title":"Arithmetic Masking","text":"","category":"section"},{"location":"types/masking/","page":"Masking","title":"Masking","text":"ArithmeticMask","category":"page"},{"location":"types/masking/#CryptoSideChannel.Masking.ArithmeticMask","page":"Masking","title":"CryptoSideChannel.Masking.ArithmeticMask","text":"ArithmeticMask(v)\n\nCreate a masked integer holding value v. Internally, v will be stored in two shares, val and mask, such that v = val - mask. The latter condition is an invariant of this datatype.\n\nIt should always be the case that mask is a primitive type, i.e. of the type Integer or GenericLog. If higher-order masking is desired, val can be of the type Masked.\n\n\n\n\n\n","category":"function"},{"location":"types/masking/#Conversion","page":"Masking","title":"Conversion","text":"","category":"section"},{"location":"types/masking/","page":"Masking","title":"Masking","text":"arithmeticToBoolean\nbooleanToArithmetic","category":"page"},{"location":"types/masking/#CryptoSideChannel.Masking.arithmeticToBoolean","page":"Masking","title":"CryptoSideChannel.Masking.arithmeticToBoolean","text":"arithmeticToBoolean(a::Masked{Arithmetic})::Masked{Boolean}\n\nExecute the algorithm outlined in Goubin's paper to convert from algebraic shares to boolean shares.\n\nSee also: arithmeticToBoolean\n\n\n\n\n\n","category":"function"},{"location":"types/masking/#CryptoSideChannel.Masking.booleanToArithmetic","page":"Masking","title":"CryptoSideChannel.Masking.booleanToArithmetic","text":"booleanToArithmetic(a::Masked{Boolean})::Masked{Arithmetic}\n\nExecute the algorithm outlined in Goubin's paper to convert from boolean shares to algebraic shares.\n\nSee also: arithmeticToBoolean\n\n\n\n\n\n","category":"function"},{"location":"types/masking/#masking_problems","page":"Masking","title":"Problems with High-level Masking","text":"","category":"section"},{"location":"types/masking/","page":"Masking","title":"Masking","text":"We defined our Masked datatype as a construct in the high-level Julia language. This poses some problems with respect to compiler optimisations. Essentially, all masking security guarantees rely on the fact that some intermediate values will never appear in memory. However, the masking approach introduces new, \"unneccessary\" computation instructions. Depending on compiler optimisations, some of the masking steps may be removed in the final executable.","category":"page"},{"location":"types/masking/","page":"Masking","title":"Masking","text":"For example, consider the masked array lookup. Recall that for a table lookup Y = TX, with X = A_X oplus M_X a table T with TX = TX oplus M_X oplus M_X is computed. Later on, the table is only accessed at index A_X. Hence, a compiler may notice that all other fields of the table are never accessed, and may optimize the code in the final program to only compute TA_X = TA_X oplus M_X oplus M_X. However, note that for computing the latter, A_X oplus M_X appears as an intermediate result. Thus, this may allow conclusions about the unmasked value.","category":"page"},{"location":"types/masking/","page":"Masking","title":"Masking","text":"The consequences of this issues are simple: This project is for academic, testing, and educational purposes only. Do not use the Masked datatype as a protection in a real-world system. Exploring ways to preserve masking through compiler optimisations in Julia could be done in future work.","category":"page"},{"location":"types/masking/#extending_masking_funs","page":"Masking","title":"Defining new methods for Masked types","text":"","category":"section"},{"location":"types/masking/","page":"Masking","title":"Masking","text":"It is possible to extend the provided methods for Masked types with custom methods.","category":"page"},{"location":"types/masking/","page":"Masking","title":"Masking","text":"The first decision that has to be made is whether the operation should be implemented for arithmetic masking or for boolean masking. In general, methods requiring arithmetic over mathbbZ are suitable for arithmetic masking, while methods using bitwise operations often require boolean masking.","category":"page"},{"location":"types/masking/","page":"Masking","title":"Masking","text":"Next, the desired operator has to be implemented. For example, we will show how to implement the boolean negation ~. Since this operator works bitwise, we will immplement the masked version on boolean masking. Recall that we want to invert a value X = A_X oplus M_X. Here, it is sufficient to simply invert the mask:","category":"page"},{"location":"types/masking/","page":"Masking","title":"Masking","text":"function Base.:(~)(a::Masked{Boolean})::Masked{Boolean}\n    Masked{Boolean,typeof(a.val),typeof(a.mask)}(a.val, ~a.mask)\nend","category":"page"},{"location":"types/masking/","page":"Masking","title":"Masking","text":"To complete this definition for all masked datatypes, we need to define the method for arithmetic masking as well. However, now simple conversion can be used to convert from arithmetic to boolean masking:","category":"page"},{"location":"types/masking/","page":"Masking","title":"Masking","text":"Base.:(~)(a::Masked{Arithmetic}) = ~arithmeticToBoolean(a)","category":"page"},{"location":"types/masking/","page":"Masking","title":"Masking","text":"warning: Warning\n","category":"page"},{"location":"types/masking/","page":"Masking","title":"Masking","text":"Be cautious when extending the Masked datatype. During any new custom operation the unmasked value should never be computed.","category":"page"},{"location":"attacks/cpa/","page":"CPA","title":"CPA","text":"CurrentModule = CryptoSideChannel.CPA","category":"page"},{"location":"attacks/cpa/#power_estimation_function","page":"CPA","title":"Power estimation function","text":"","category":"section"},{"location":"attacks/cpa/","page":"CPA","title":"CPA","text":"Intros concept power estimation function. Some examples? TODO","category":"page"},{"location":"attacks/cpa/#CPA-attacks-against-AES","page":"CPA","title":"CPA attacks against AES","text":"","category":"section"},{"location":"attacks/cpa/","page":"CPA","title":"CPA","text":"CPA_AES_analyze\nCPA_AES_analyze_traces\nCPA_AES_analyze_manual","category":"page"},{"location":"attacks/cpa/#CryptoSideChannel.CPA.CPA_AES_analyze","page":"CPA","title":"CryptoSideChannel.CPA.CPA_AES_analyze","text":"CPA_AES_analyze(sample_function, leakage_model)\n\nPerforms a CPA attack against AES, where traces are collected from a specified function.\n\nArguments\n\nsample_function: single-argument function that takes an input AES input (MVector{16, UInt8}) and returns a power trace as an array of numbers for this input.\nleakage_model: a function reducing a processed value R to their estimated side-channel emissions W_R\n\nReturns\n\nThe recovered AES key\n\n\n\n\n\n","category":"function"},{"location":"attacks/cpa/#CryptoSideChannel.CPA.CPA_AES_analyze_traces","page":"CPA","title":"CryptoSideChannel.CPA.CPA_AES_analyze_traces","text":"CPA_AES_analyze_manual(plaintexts::Vector, traces::Matrix, leakage_model)\n\nPerforms a CPA attack against AES on given traces.\n\nArguments\n\nplaintexts: A vector of size N, where N is the number of power traces sampled.\ntraces: A matrix of size M * N, where M is the number of samples per trace. Power traces are stored in column-major order, i.e. it is expected that traces[:,i] refers to the powertrace generated with plaintexts[i]\nleakage_model: a function reducing a processed value R to their estimated side-channel emissions W_R\n\nReturns\n\nThe recovered AES key\n\n\n\n\n\n","category":"function"},{"location":"attacks/cpa/#CryptoSideChannel.CPA.CPA_AES_analyze_manual","page":"CPA","title":"CryptoSideChannel.CPA.CPA_AES_analyze_manual","text":"CPA_AES_analyze_manual(plaintexts::Vector, traces::Matrix, power_estimate)\n\nPerforms a CPA attack against AES on given traces.\n\nArguments\n\nplaintexts: A vector of size N, where N is the number of power traces sampled.\ntraces: A matrix of size M * N, where M is the number of samples per trace. Power traces are stored in column-major order, i.e. it is expected that traces[:,i] refers to the powertrace generated with plaintexts[i]\npower_estimate: A function that takes a plaintext::MVector{16, UInt6}, a key index (1 <= key_guess_index <= 16), and a key guess (0 <= key_guess <= 255) and returns an hypothesis on power consumption.   For example, a classical implementation of this function for AES with Hamming weight would be   power_estimate(plaintext, key_guess_index, key_guess) =       Base.count_ones(AES.c_sbox[(plaintext[key_guess_index] ⊻ key_guess)+1])\n\n\n\n\n\n","category":"function"},{"location":"attacks/cpa/#CPA-attacks-against-SPECK","page":"CPA","title":"CPA attacks against SPECK","text":"","category":"section"},{"location":"attacks/cpa/","page":"CPA","title":"CPA","text":"Attacks against SPECK are a bit more difficult, since both key parts (the left 64 bits and the right 64 bits) have to be attacked differently.","category":"page"},{"location":"attacks/cpa/","page":"CPA","title":"CPA","text":"CPA_SPECK_analyze\nCPA_SPECK_analyze_traces","category":"page"},{"location":"attacks/cpa/#CryptoSideChannel.CPA.CPA_SPECK_analyze","page":"CPA","title":"CryptoSideChannel.CPA.CPA_SPECK_analyze","text":"CPA_SPECK_analyze(sample_function)\n\nPerforms a CPA attack against SPECK.\n\nArguments\n\nsample_function: a single-argument function that takes a SPECK input (Tuple{UInt64, UInt64}) and returns a power trace (array of numbers) for this input.\nleakage_model: a function reducing a processed value R to their estimated side-channel emissions W_R\nN: the amount of traces to collect\n\nReturns\n\nThe reconstructed SPECK key as a Tuple{UInt64, UInt64}\n\n\n\n\n\n","category":"function"},{"location":"attacks/cpa/#CryptoSideChannel.CPA.CPA_SPECK_analyze_traces","page":"CPA","title":"CryptoSideChannel.CPA.CPA_SPECK_analyze_traces","text":"CPA_SPECK_analyze_traces(plaintexts::Vector, traces::Matrix, leakage_model)\n\nPerform a CPA attack against SPECK on the provided traces.\n\nArguments\n\nplaintexts: A Vector of size N, where N is the number of power traces sampled.\ntraces: A Matrix of size M * N, where M is the number of samples per trace.\n\nPower traces are stored in column-major order, i.e. it is expected that traces[i,:] refers  to the powertrace generated with plaintexts[i]\n\nleakage_model: a function reducing a processed value R to their estimated side-channel emissions W_R\n\nReturns\n\nThe reconstructed SPECK key as a Tuple{UInt64, UInt64}\n\n\n\n\n\n","category":"function"},{"location":"attacks/cpa/#Real-world-attacks-against-AES","page":"CPA","title":"Real-world attacks against AES","text":"","category":"section"},{"location":"attacks/cpa/","page":"CPA","title":"CPA","text":"In the file test/aes-realworld, a real-world CPA attack is implemented. This attack uses the Northeastern University TeSCASE dataset, which can be obtained here. The attacked traces have been generated on a SASEBO board that executes the AES algorithm.","category":"page"},{"location":"types/logging/#logging","page":"Logging","title":"Logging: The GenericLog Datatype","text":"","category":"section"},{"location":"types/logging/","page":"Logging","title":"Logging","text":"CurrentModule = CryptoSideChannel.Logging\nDocTestSetup = quote\n    using CryptoSideChannel\nend","category":"page"},{"location":"types/logging/","page":"Logging","title":"Logging","text":"Logging.GenericLog","category":"page"},{"location":"types/logging/#CryptoSideChannel.Logging.GenericLog","page":"Logging","title":"CryptoSideChannel.Logging.GenericLog","text":"struct GenericLog{U,S,T}\n    val::T\nend\n\nThe GenericLog datatype behaves like an integer, but additionally logs a trace of all values contained. Technically, this type appends a reduced value to an array every time a operation is performed on it.\n\nType Arguments\n\nT is the underlying type that our type should mimic. T may be a primitive integer type (like UInt8 or Int), or any integer-like type (for example, another instance of GenericLog or a Masked integer).\nU should be a container holding a reduction function. The purpose of this reduction function is to preprocess values of the underlying type for logging. Most commonly, only a value derived from the underlying value should be logged, like the Hamming weight or the least significant bit. Such a derived value can be computed with the reduction function. Further details can be found at Reduction functions.\nS is a closure returning the array where values should be logged to. Note that S must be a bits type. This can only be the case if the array returned by S is a global variable.\n\n\n\n\n\n","category":"type"},{"location":"types/logging/","page":"Logging","title":"Logging","text":"Most operations on integers can also be performed on instances of GenericLog. By default, this includes the most common operations like calculations, array accesses, and more. However, it is easy to extend this functionality to other methods if desired. See the chapter on Defining new methods for GenericLog types for more details.","category":"page"},{"location":"types/logging/","page":"Logging","title":"Logging","text":"It may be useful to extract the content of a GenericLog type, for example, at the end of a cryptographic calculation.","category":"page"},{"location":"types/logging/","page":"Logging","title":"Logging","text":"Logging.extractValue","category":"page"},{"location":"types/logging/#CryptoSideChannel.Logging.extractValue","page":"Logging","title":"CryptoSideChannel.Logging.extractValue","text":"extractValue(a::GenericLog)\nextractValue(a::Integer)\n\nExtracts the internal value from the GenericLog datatype. Behaves like the identity function if an Integer value is passed.\n\n\n\n\n\n","category":"function"},{"location":"types/logging/#Reduction-functions","page":"Logging","title":"Reduction functions","text":"","category":"section"},{"location":"types/logging/","page":"Logging","title":"Logging","text":"A reduction function for a GenericLog over base type T should take any value of type T, and produce any result that eventually is logged. Reasonable choices for reduction functions could be a model of side-channel emissions. For example, the Hamming weight could be a possible model which is already pre-defined. The following types with commonly used reduction functions are already pre-defined:","category":"page"},{"location":"types/logging/","page":"Logging","title":"Logging","text":"There are already several logging datatypes pre-defined. Creating instances of those types is as easy as specifying a closure returning the logging destination, and the underlying value.","category":"page"},{"location":"types/logging/#predefined_types","page":"Logging","title":"Pre-defined logging types","text":"","category":"section"},{"location":"types/logging/","page":"Logging","title":"Logging","text":"The following logging types are already pre-defined:","category":"page"},{"location":"types/logging/","page":"Logging","title":"Logging","text":"HammingWeightLog\nFullLog\nSingleBitLog\nStochasticLog","category":"page"},{"location":"types/logging/#CryptoSideChannel.Logging.HammingWeightLog","page":"Logging","title":"CryptoSideChannel.Logging.HammingWeightLog","text":"HammingWeightLog(val, stream)\n\nCreates a logging datatype that logs the Hamming weight of the underlying value.\n\nArguments\n\nval: the value that should be wrapped around.\nstream: A closure returning the array that should be logged to. Note that stream must be a bits type.\n\nExample\n\njulia> trace = [];\n\njulia> closure = () -> trace;\n\njulia> a = Logging.HammingWeightLog(42, closure)\nLog{Int64, 42}\njulia> b = a + 1\nLog{Int64, 43}\njulia> c = a - 42\nLog{Int64, 0}\njulia> trace\n2-element Vector{Any}:\n 4\n 0\n\nNotice that (43)_10 = (101011)_2. Hence, the Hamming weight of 43 is 4.\n\n\n\n\n\n","category":"function"},{"location":"types/logging/#CryptoSideChannel.Logging.FullLog","page":"Logging","title":"CryptoSideChannel.Logging.FullLog","text":"FullLog(val, stream)\n\nCreates a logging datatype that logs the full underlying value.\n\nArguments\n\nval: the value that should be wrapped around.\nstream: A closure returning the array that should be logged to. Note that stream must be a bits type.\n\nExample\n\njulia> trace = [];\n\njulia> closure = () -> trace;\n\njulia> a = Logging.FullLog(42, closure)\nLog{Int64, 42}\njulia> b = a + 1\nLog{Int64, 43}\njulia> c = a - 42\nLog{Int64, 0}\njulia> trace\n2-element Vector{Any}:\n 43\n  0\n\n\n\n\n\n","category":"function"},{"location":"types/logging/#CryptoSideChannel.Logging.SingleBitLog","page":"Logging","title":"CryptoSideChannel.Logging.SingleBitLog","text":"SingleBitLog(val, stream, bit)\n\nCreates a logging datatype that logs the value of a single bit of the underlying value. The bit that is logged is selected with the bit argument.\n\nArguments\n\nval: the value that should be wrapped around.\nstream: A closure returning the array that should be logged to. Note that stream must be a bits type.\nbit: The position of the bit that should be logged, where 0 is the least significant bit.\n\n\n\n\n\n","category":"function"},{"location":"types/logging/#CryptoSideChannel.Logging.StochasticLog","page":"Logging","title":"CryptoSideChannel.Logging.StochasticLog","text":"function StochasticLog(val, stream, template_for_value, noise_for_value)\n\nConstructs a logging datatype that logs vectors.\n\nArguments\n\nval: The value the logging datatype should hold.\nstream: A closure to the array that should be logged to.\nmean_for_value must be a function returning the vector meanx_m for a value m.\nnoise_for_value is a function returning a MvNormal distribution with zero mean. This distribution represents the noise. For each value, a random vector is sampled from this noise and added to the respective mean.\n\n\n\n\n\n","category":"function"},{"location":"types/logging/#Using-custom-reduction-functions","page":"Logging","title":"Using custom reduction functions","text":"","category":"section"},{"location":"types/logging/","page":"Logging","title":"Logging","text":"Besides the pre-defined types, this framework allows free choices of reduction functions, hence providing great flexibility. To define custom reduction functions, the SingleFunctionLog interface should be used. With this type, it is possible to specify a custom function that takes the intermemdiate value and output the reduced result.","category":"page"},{"location":"types/logging/","page":"Logging","title":"Logging","text":"SingleFunctionLog","category":"page"},{"location":"types/logging/#CryptoSideChannel.Logging.SingleFunctionLog","page":"Logging","title":"CryptoSideChannel.Logging.SingleFunctionLog","text":"abstract type SingleFunctionLog{F} <: LogFunction end\n\nA wrapper for simple reduction functions that take a single argument and outputs a reduced value.\n\n\n\n\n\n","category":"type"},{"location":"types/logging/","page":"Logging","title":"Logging","text":"For example, it is possible to define the HammingWeightLog based on this method as follows:","category":"page"},{"location":"types/logging/","page":"Logging","title":"Logging","text":"HammingWeightLog(val, stream)  =\n    GenericLog{SingleFunctionLog{Base.count_ones},stream,typeof(val)}(val)","category":"page"},{"location":"types/logging/#Logging-to-an-array","page":"Logging","title":"Logging to an array","text":"","category":"section"},{"location":"types/logging/","page":"Logging","title":"Logging","text":"TODO why closures TODO how to provide array TODO array must be in global scope.","category":"page"},{"location":"types/logging/#extending_log_funs","page":"Logging","title":"Defining new methods for GenericLog types","text":"","category":"section"},{"location":"types/logging/","page":"Logging","title":"Logging","text":"All basic operations provided by the Julia standard library can also be executed on GenericLog types. However, there may be the need for custom operations, e.g. defined by a third-party library. Implementing a new binary operation on GenericLog consists of defining the following three methods:","category":"page"},{"location":"types/logging/","page":"Logging","title":"Logging","text":"function Base.$op(a::GenericLog{U,S}, b::GenericLog) where {U,S}\n    res = Base.$op(extractValue(a), extractValue(b))\n    result = GenericLog{U,S,typeof(res)}(res)\n    push!(typeof(b).parameters[2](), logValue(result))\n    result\nend\n\nBase.$op(a::Integer, b::GenericLog{U,S}) where {U,S} = ...\nBase.$op(a::GenericLog{U,S}, b::Integer) where {U,S} = ...","category":"page"},{"location":"attacks/dpa/#DPA","page":"DPA","title":"DPA","text":"","category":"section"},{"location":"attacks/dpa/","page":"DPA","title":"DPA","text":"CurrentModule = CryptoSideChannel.DPA","category":"page"},{"location":"attacks/dpa/","page":"DPA","title":"DPA","text":"This framework implements differential power attacks against AES. On a high level, the attacks are implemented using the following two methods:","category":"page"},{"location":"attacks/dpa/","page":"DPA","title":"DPA","text":"DPA_AES_analyze_traces\nDPA_AES_analyze","category":"page"},{"location":"attacks/dpa/#CryptoSideChannel.DPA.DPA_AES_analyze_traces","page":"DPA","title":"CryptoSideChannel.DPA.DPA_AES_analyze_traces","text":"DPA_AES_analyze_traces(plaintexts::Vector, traces::Matrix, power_estimate)\n\nPerforms a DPA attack against AES on given traces.\n\nArguments\n\nplaintexts: A vector of size N, where N is the number of power traces sampled.\ntraces: A matrix of size M * N, where M is the number of samples per trace. Power traces are stored in column-major order, i.e. it is expected that traces[:,i] refers to the powertrace generated with plaintexts[i]\n\nReturns\n\nThe recovered AES key.\n\n\n\n\n\n","category":"function"},{"location":"attacks/dpa/#CryptoSideChannel.DPA.DPA_AES_analyze","page":"DPA","title":"CryptoSideChannel.DPA.DPA_AES_analyze","text":"DPA_AES_analyze(sample_function; N = 2^12)\n\nPerforms a DPA attack against AES, where traces are collected from a specified function.\n\nArguments\n\nsample_function: single-argument function that takes an input AES input (MVector{16, UInt8}) and returns a power trace as an array of numbers for this input.\nN: the number of traces to collect before performing the attack. Defaults to 2^12\n\nReturns\n\nThe recovered AES key\n\nExample\n\njulia> test_key = hex2bytes(\"00112233445566778899aabbccddeeff\");\njulia> sample_function(x) = DPA.sample_AES_power_trace(test_key, x);\njulia> recovered_key = DPA.DPA_AES_analyze(sample_function);\n[...]\njulia> print(recovered_key)\nUInt8[0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]\n\n\n\n\n\n","category":"function"},{"location":"attacks/dpa/#Internal-functions","page":"DPA","title":"Internal functions","text":"","category":"section"},{"location":"attacks/dpa/","page":"DPA","title":"DPA","text":"Internally, DPA groups the traces into two partitions based on a key byte guess. This partitioning is created with the following method","category":"page"},{"location":"attacks/dpa/","page":"DPA","title":"DPA","text":"DPA_AES_select","category":"page"},{"location":"attacks/dpa/#CryptoSideChannel.DPA.DPA_AES_select","page":"DPA","title":"CryptoSideChannel.DPA.DPA_AES_select","text":"function select(plaintext, key_guess, key_guess_index)::Bool\n\nDecides in which partition a trace with input plaintext should fall when the key_guess_index-th key byte is set to key_guess.\n\nArguments\n\nplaintext: The text that was the input for the recorded power trace.\nkey_guess_index: The targeted AES key byte.\nkey_guess: The current guess for the targeted key byte.\n\nReturns\n\nTrue if the trace belongs to the first partition. False if the trace should belong to the second partition.\n\n\n\n\n\n","category":"function"},{"location":"attacks/template/#Template-attacks","page":"Template","title":"Template attacks","text":"","category":"section"},{"location":"attacks/template/","page":"Template","title":"Template","text":"CurrentModule = CryptoSideChannel.TemplateAttacks","category":"page"},{"location":"attacks/template/#Generating-vector-distributions","page":"Template","title":"Generating vector distributions","text":"","category":"section"},{"location":"attacks/template/","page":"Template","title":"Template","text":"A pooled distribution (consisting of different mean vectors for all values and a common covariance matrix) is stored in the following Templates struct:","category":"page"},{"location":"attacks/template/","page":"Template","title":"Template","text":"Templates","category":"page"},{"location":"attacks/template/#CryptoSideChannel.TemplateAttacks.Templates","page":"Template","title":"CryptoSideChannel.TemplateAttacks.Templates","text":"The Templates struct stores a pooled noise covariance matrix, as well as mean vectors for all integers that are possibly loaded.\n\nIf the integer x is processed, a random vector from distribution is drawn. Then, values[x] is added to this random vector.\n\n\n\n\n\n","category":"type"},{"location":"attacks/template/","page":"Template","title":"Template","text":"These distributions can be created either manually to model a specific behaviour, or can be drawn randomly for testing purposes. The following two methods generate random distributions:","category":"page"},{"location":"attacks/template/","page":"Template","title":"Template","text":"random_diagonal_multivariate_distribution\nrandom_uncorrelated_templates","category":"page"},{"location":"attacks/template/#CryptoSideChannel.TemplateAttacks.random_diagonal_multivariate_distribution","page":"Template","title":"CryptoSideChannel.TemplateAttacks.random_diagonal_multivariate_distribution","text":"random_diagonal_multivariate_distribution(d::Integer)\n\nGenerate a random normal multivariate distribution over d dimensions. The mean will be a vector chosen randomly from 0 1^d.\n\nNote that all random values are uncorrelated. Hence, our covariance matrix is a diagonal matrix.\n\n\n\n\n\n","category":"function"},{"location":"attacks/template/#CryptoSideChannel.TemplateAttacks.random_uncorrelated_templates","page":"Template","title":"CryptoSideChannel.TemplateAttacks.random_uncorrelated_templates","text":"random_uncorrelated_templates(dimensions::Integer, max_value::Integer)\n\nGenerate a random template over d dimensions, that supports operations on integers between 0 and max_value.\n\n\n\n\n\n","category":"function"},{"location":"attacks/template/#Sampling-vectors","page":"Template","title":"Sampling vectors","text":"","category":"section"},{"location":"attacks/template/","page":"Template","title":"Template","text":"Usually, template attacks only target single instructions. For example, the target of an attack could be a single load instruction executed on a microcontroller. Those small targeted instructions are provided by the following two functions:","category":"page"},{"location":"attacks/template/","page":"Template","title":"Template","text":"single_load_instruction\nmulti_load_instructions","category":"page"},{"location":"attacks/template/#CryptoSideChannel.TemplateAttacks.single_load_instruction","page":"Template","title":"CryptoSideChannel.TemplateAttacks.single_load_instruction","text":"single_load_instruction(value)\n\nSimulate a single load instruction of value.\n\n\n\n\n\n","category":"function"},{"location":"attacks/template/#CryptoSideChannel.TemplateAttacks.multi_load_instructions","page":"Template","title":"CryptoSideChannel.TemplateAttacks.multi_load_instructions","text":"multi_load_instructions(a::Vector)\n\nSimulate multiple consecutive load instructions for all values in the vector a, in the order of the vector.\n\n\n\n\n\n","category":"function"},{"location":"attacks/template/","page":"Template","title":"Template","text":"Given the functions that should be sampled, template vectors are collected using the following sample_function. If multiple attack traces with the same input are required, those can be generated with generate_attack_vectors.","category":"page"},{"location":"attacks/template/","page":"Template","title":"Template","text":"sample_function\ngenerate_attack_vectors","category":"page"},{"location":"attacks/template/#CryptoSideChannel.TemplateAttacks.sample_function","page":"Template","title":"CryptoSideChannel.TemplateAttacks.sample_function","text":"sample_function(templates::Templates, fun, value)\n\nSample the provided function fun on input value.\n\nArguments\n\ntemplates defines the underlying emissions that should be simulated (i.e. mean and covariance matrices for values).\nfun must be a function taking a single integer. This function should describe the operation that is targeted. For example, fun could be single_load_instruction or multi_load_instructions.\nvalue should be an integer, or an array of integers that fun is executed on.\n\nReturns\n\nThe leakage vector that the execution of fun on value would produce, assuming that the emissions are defined by templates.\n\n\n\n\n\n","category":"function"},{"location":"attacks/template/#CryptoSideChannel.TemplateAttacks.generate_attack_vectors","page":"Template","title":"CryptoSideChannel.TemplateAttacks.generate_attack_vectors","text":"generate_attack_vectors(templates::Templates, secret; fun = single_load_instruction, N = 2^10)\n\nSample N attack vectors of the function fun.\n\nArguments\n\ntemplates stores the noise distribution of our side-channel.\nsecret is the secret value that is loaded for our attack. For example, this could be a single key byte.\nfun is the function that processes the secret value. This defaults to a single load instruction. This function must take a single integer.\nN is the number of attack traces to produce.\n\nReturns\n\nA list of side-channel attack vectors that record the operation of fun(secret). The function fun must have the type signature Int -> Any. fun will be executed on input secret, which should be an integer or an vector of integers.\n\nThe attack vectors are sampled by using the sample_function.\n\n\n\n\n\n","category":"function"},{"location":"attacks/template/#Attacking","page":"Template","title":"Attacking","text":"","category":"section"},{"location":"attacks/template/","page":"Template","title":"Template","text":"template_core_attack","category":"page"},{"location":"attacks/template/#CryptoSideChannel.TemplateAttacks.template_core_attack","page":"Template","title":"CryptoSideChannel.TemplateAttacks.template_core_attack","text":"template_core_attack(profiled_vectors::AbstractMatrix, inputs::AbstractVector, attack_vectors::AbstractMatrix)\n\nArguments\n\ninputs: A vector containing N entries, where N is the number of sampled vectors. At position x shall be the input that was used to generate the x-th vector.\nprofiled_vectors: A M times N matrix. The column profiled_vectors[:,x] should contain the data that was generated on input x.\nattack_vectors: A M times K matrix, where K is the number of traces from the attacked device.  Traces are stored in column-major order. All traces must be generated with the same secret input.\n\nReturns\n\nA vector of tuples (likelyhood, value) for all values in inputs, sorted by decreasing likelyhood of the value.\n\n\n\n\n\n","category":"function"},{"location":"types/create-traces/#Creating-your-own-side-channel-traces","page":"Create your own traces","title":"Creating your own side-channel traces","text":"","category":"section"},{"location":"types/create-traces/","page":"Create your own traces","title":"Create your own traces","text":"One of the main features of this project is the ability to create traces of an arbitrary program working with integers. For example, this feature can be used to obtain traces from a custom cryptographic algorithms which then can be analyzed for vulnerabilities. Furthermore, trace generation can also be used for generating data for student exercises. A possible task idea is to release a set of a few thousand traces with the goal to reconstruct the secret key used.","category":"page"},{"location":"types/create-traces/","page":"Create your own traces","title":"Create your own traces","text":"In this section, we will look at AES as an example on how to create your own side-channel traces using this framework:","category":"page"},{"location":"types/create-traces/#Unmasked-traces","page":"Create your own traces","title":"Unmasked traces","text":"","category":"section"},{"location":"types/create-traces/","page":"Create your own traces","title":"Create your own traces","text":"To generate unmasked traces, the following must be provided:","category":"page"},{"location":"types/create-traces/","page":"Create your own traces","title":"Create your own traces","text":"A trace collection array. All collected values will be appended to this array.","category":"page"},{"location":"types/create-traces/","page":"Create your own traces","title":"Create your own traces","text":"note: Note\nThe trace-array must be a global variable.","category":"page"},{"location":"types/create-traces/","page":"Create your own traces","title":"Create your own traces","text":"The reduction function: Whenever a value x is processed, the value reduce_function(x) is appended to the array. In this example, we choose reduce_function = x -> Base.count_ones(x) + rand(d), which computes the Hamming weight with some noise.","category":"page"},{"location":"types/create-traces/","page":"Create your own traces","title":"Create your own traces","text":"Then, the trace collection code is:","category":"page"},{"location":"types/create-traces/","page":"Create your own traces","title":"Create your own traces","text":"trace = []\n\nfunction encrypt_collect_trace(pt::MVector{16, UInt8})\n    global trace\n    trace = []\n    clos = () -> trace\n    d = Distributions.Normal(0, 2)\n\n    reduce_function = x -> Base.count_ones(x) + rand(d)\n\n    kl = map(x -> Logging.SingleFunctionLog(x, clos, reduce_function), hex2bytes(SECRET_KEY))\n    ptl = map(x -> Logging.SingleFunctionLog(x, clos, reduce_function), pt)\n\n    AES.AES_encrypt(ptl, kl)\n\n    return copy(trace)\nend","category":"page"},{"location":"types/create-traces/#Masked-traces","page":"Create your own traces","title":"Masked traces","text":"","category":"section"},{"location":"types/create-traces/","page":"Create your own traces","title":"Create your own traces","text":"Collecting masked traces is a very similar process. The only difference is that the logging datatype of input and key must be encapsulated in a masking datatype:","category":"page"},{"location":"types/create-traces/","page":"Create your own traces","title":"Create your own traces","text":"coll = []\n\nfunction encrypt_collect_masked_trace(pt::MVector{16, UInt8})\n    global coll\n    global key\n    coll = []\n    clos = () -> coll\n\n    reduce_function = x -> Base.count_ones(x)\n\n    kl = map(x -> Masking.BooleanMask(Logging.SingleFunctionLog(x, clos, reduce_function)), key)\n    ptl = map(x -> Masking.BooleanMask(Logging.SingleFunctionLog(x, clos, reduce_function)), pt)\n\n    output = (Logging.extractValue ∘ Masking.unmask).(AES.AES_encrypt(ptl, kl))\n\n    return (output, copy(coll))\nend","category":"page"},{"location":"attacks/keycombination/#Key-combination","page":"Key combination","title":"Key combination","text":"","category":"section"},{"location":"attacks/keycombination/","page":"Key combination","title":"Key combination","text":"CurrentModule = CryptoSideChannel.TemplateAttacks","category":"page"},{"location":"attacks/keycombination/","page":"Key combination","title":"Key combination","text":"LikelyKey\nincrease!","category":"page"},{"location":"attacks/keycombination/#CryptoSideChannel.TemplateAttacks.LikelyKey","page":"Key combination","title":"CryptoSideChannel.TemplateAttacks.LikelyKey","text":"struct LikelyKey\n    keylist::Vector{Vector{Integer}}\nend\n\nThis struct merges different key bytes for which probabilities are known to a whole key, by iterating first over keys that are more likely.\n\nKeys are stored as lists of lists, where the outer lists represent the respective key byte (i.e. the first list represents the first key byte). The inner lists must be sorted according to the probability of a specific byte occuring.\n\nExample\n\njulia> k = LikelyKey([[1, 2, 3], [4, 5, 6]])\njulia> for x = k\n         print(x); print(\" \")\n       end\n[1, 4] [2, 4] [1, 5] [3, 4] [2, 5] [1, 6] [3, 5] [2, 6] [3, 6]\n\n\n\n\n\n","category":"type"},{"location":"attacks/keycombination/#CryptoSideChannel.TemplateAttacks.increase!","page":"Key combination","title":"CryptoSideChannel.TemplateAttacks.increase!","text":"function increase!(s::Stack{Int}, size::Int)\n\nModifies the stack to the next larger state. All stacks that contain n elements will be seen before any stack containing n + 1 elements. No element in the stack will be greater than size.\n\nIf results from this method are used with iterate, all lists will be iterated.\n\nInternals\n\nIf s has n elements, and there is a lexicographically larger stack with n elements, return a lexicographically larger stack corresponding to a new list (as described in Base.iterate).\n\nOtherwise, returns the lexicographically smallest stack with n+1 elements.\n\n\n\n\n\n","category":"function"},{"location":"attacks/keycombination/#Iteration-interface","page":"Key combination","title":"Iteration interface","text":"","category":"section"},{"location":"attacks/keycombination/","page":"Key combination","title":"Key combination","text":"Base.iterate(k::LikelyKey)\nBase.length(k::LikelyKey)\nBase.eltype(k::LikelyKey)","category":"page"},{"location":"attacks/keycombination/#Base.iterate-Tuple{CryptoSideChannel.TemplateAttacks.LikelyKey}","page":"Key combination","title":"Base.iterate","text":"Base.iterate(k::LikelyKey)\nBase.iterate(k::LikelyKey, state::Stack{Int})\n\nIterate over a LikelyKey. Keys that are more likely by the internal sorting of k will be seen first.\n\nInternally, the current status of the iteration is represented by a stack. The contents of this stack are indices of the outer list. An occurence of a list index means that at this position in the key the next likely value should be tried. For example, a stack containing the following values: [1, 1, 1, 3, 3, 4, 4, 5] would be interpreted as follows:\n\nFor the first key byte, take the fourth most likely (since there are three 1s in our stack, we take the 3+1th most likely element)\nThe second key byte is the most likely (since there is no 2 in our stack)\nThe third key byte is the third most likely (there are two 3s in our stack)\nSame for the fourth key byte: Take the third most likely\nFor the fifth key byte, take the second most likely (there is one 5 in our stack)\n\nWith this system, stacks with less entries will always correspond to more likely lists than stacks containing more entries.\n\n\n\n\n\n","category":"method"},{"location":"attacks/keycombination/#Base.length-Tuple{CryptoSideChannel.TemplateAttacks.LikelyKey}","page":"Key combination","title":"Base.length","text":"Base.length(k::LikelyKey)\n\nReturns the length of this iterator, which is the product of the length of all lists.\n\n\n\n\n\n","category":"method"},{"location":"attacks/keycombination/#Base.eltype-Tuple{CryptoSideChannel.TemplateAttacks.LikelyKey}","page":"Key combination","title":"Base.eltype","text":"Base.eltype(k::LikelyKey)\n\nReturns the type of the elements that are iterated over. This is always a vector of key parts.\n\n\n\n\n\n","category":"method"},{"location":"#CryptoSideChannel.jl:-A-customizable-side-channel-modelling-and-analysis-framework-in-Julia","page":"Home","title":"CryptoSideChannel.jl: A customizable side-channel modelling and analysis framework in Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This library focuses on generic side-channel analysis of cryptographic algorithms. The implementation uses custom types that behave like integers. However, those types may additionally log their values, or mask the internal representation of their values. In combination, this allows for easy recording of masked-and unmasked side-channels for educational and testing purposes. See the chapter on Custom Types for more information about this part.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lastly, this project implements several attacks against the recorded traces. See the chapter on Attacks for more details.","category":"page"},{"location":"#Ciphers","page":"Home","title":"Ciphers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, two ciphers are implemented: The SPECK cipher, and the AES cipher suite.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CryptoSideChannel.AES","category":"page"},{"location":"#CryptoSideChannel.AES","page":"Home","title":"CryptoSideChannel.AES","text":"This module provides an implementation of the AES algorithm.\n\nFurther documentation can be found at AES.\n\n\n\n\n\n","category":"module"},{"location":"","page":"Home","title":"Home","text":"CryptoSideChannel.SPECK","category":"page"},{"location":"#CryptoSideChannel.SPECK","page":"Home","title":"CryptoSideChannel.SPECK","text":"This module implements the SPECK cipher.\n\nMore documentation can be found in the chapter SPECK.\n\n\n\n\n\n","category":"module"},{"location":"#Custom-Types","page":"Home","title":"Custom Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package currently provides two classes of additional types that mimic integers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Integer Types page for a more detailed explanation on how to declare custom integer types.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The GenericLog type allows for recording traces of program executions.\nThe Masked type internally splits its value into two shares. Thus, the content of a Masked integer should never be observable in memory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CryptoSideChannel.Logging","category":"page"},{"location":"#CryptoSideChannel.Logging","page":"Home","title":"CryptoSideChannel.Logging","text":"The Logging module allows for recording traces of program executions. This module provides the type GenericLog, which can be substituted for an integer. With this type, arithmetic operations, as well as certain memory operations will be logged to a trace array.\n\nFurther documentation is available at Logging.\n\n\n\n\n\n","category":"module"},{"location":"","page":"Home","title":"Home","text":"CryptoSideChannel.Masking","category":"page"},{"location":"#CryptoSideChannel.Masking","page":"Home","title":"CryptoSideChannel.Masking","text":"The Masking module provides integer types that mask values. Hence, those values do never occur in memory while operations on it are performed. This makes side-channel attacks more difficult.\n\nFurther documentation is available at Masking.\n\n\n\n\n\n","category":"module"},{"location":"#Attacks","page":"Home","title":"Attacks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Multiple side-channel attacks against the ciphers above have been implemented:","category":"page"},{"location":"","page":"Home","title":"Home","text":"DPA\nCPA\nTemplate Attacks","category":"page"},{"location":"","page":"Home","title":"Home","text":"CryptoSideChannel.DPA","category":"page"},{"location":"#CryptoSideChannel.DPA","page":"Home","title":"CryptoSideChannel.DPA","text":"The DPA module implements generic Differential Power Attacks. The implementation largely follows the one described by Kocher in this paper, but is generalized to support other cryptographic algorithms.\n\nA detailed documentation can be found at DPA\n\n\n\n\n\n","category":"module"},{"location":"","page":"Home","title":"Home","text":"CryptoSideChannel.CPA","category":"page"},{"location":"#CryptoSideChannel.CPA","page":"Home","title":"CryptoSideChannel.CPA","text":"The CPA module implements generic Correlation Power Attacks.\n\nMore documentation is available at CPA\n\n\n\n\n\n","category":"module"},{"location":"","page":"Home","title":"Home","text":"CryptoSideChannel.TemplateAttacks","category":"page"},{"location":"#CryptoSideChannel.TemplateAttacks","page":"Home","title":"CryptoSideChannel.TemplateAttacks","text":"This module implements Template attacks on cryptographic side channels.\n\nMore information can be found at Template attacks\n\n\n\n\n\n","category":"module"},{"location":"types/integer-types/#integer_types","page":"Integer Types","title":"Integer Types","text":"","category":"section"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"CurrentModule = CryptoSideChannel.Logging\nDocTestSetup = quote\n    using CryptoSideChannel\nend","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"By default, Julia ships with an abstract Integer type, which shall be the supertype for all integers.","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"Furthermore, Julia's base comes with primitive Integer types like Int8, UInt8, Int64, UInt64. Note that Int == Int64 on 64-bit systems. Hence, Int is a primitive type as well.","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"Eventually, computations are executed on primitive Integer types, while methods are often dispatched on the abstract Integer datatype. For this to work, it is crucial that the primitive types are subtypes of the abstract Integer type, which can be confirmed easily:","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"julia> UInt8 <: Integer\ntrue\njulia> Int64 <: Integer\ntrue","category":"page"},{"location":"types/integer-types/#Custom-Integer-Types","page":"Integer Types","title":"Custom Integer Types","text":"","category":"section"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"An important goal of this library is to provide new types that behave similarly to integers, but include custom functionality. Those types are constructed using a duck typing approach:","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"If it walks like a duck and it quacks like a duck, then it must be a duck","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"Thus, our newly created types will not be a subtype of Integer, but instead only behave like integers in certain contexts. A detailed discussion on this choice can be found in this section.","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"Technically, a definition of a very simple custom integer type could look as follows:","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"struct MyInt\n    value::Int\nend","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"Now, using Julia's powerful multiple dispatch functionality, we can start defining methods on our custom integer. For example, addition could be defined in the following way:","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"function Base.:(+)(a::MyInt, b::MyInt)\n    # custom code (if desired) here\n    MyInt(a.value + b.value)\nend","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"Since we want our type to be compatible with normal integers, it is also necessary to define the following two procedures:","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"function Base.:(+)(a::MyInt, b::Integer)\n    # custom code (if desired) here\n    MyInt(a.value + b)\nend\nfunction Base.:(+)(a::Integer, b::MyInt)\n    # custom code (if desired) here\n    MyInt(a + b.value)\nend","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"Extending this to other operators is, of course, extremely tedious and results in large code duplicates. This can be avoided by the use of metaprogramming to generate those functions. Consider the following function definitions instead:","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"extractValue(a::MyInt) = a.value\nextractValue(a::Integer) = a\n\nfunction Base.:(+)(a::MyInt, b::MyInt)\n    MyInt(extractValue(a) + extractValue(b))\nend\nfunction Base.:(+)(a::MyInt, b::Integer)\n    MyInt(extractValue(a) + extractValue(b))\nend\nfunction Base.:(+)(a::Integer, b::MyInt)\n    MyInt(extractValue(a) + extractValue(b))\nend","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"Now, all three procedures have the exact same body. Hence, we can subsume all three procedures by using Julia's metaprogramming:","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"for type = ((:MyInt, :MyInt), (:MyInt, :Integer), (:Integer, :MyInt))\n    eval(quote\n        function Base.:(+)(a::$(type[1]), b::$(type[2]))\n            # custom code here\n            MyInt(extractValue(a) + extractValue(b))\n        end\n    end)\nend","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"Here, the outer for-loop is evaluated at compile time. Thus, three new methods are registered by evaluating the generated function body.","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"Of course, we like to extend this construction to other operators. We can achieve this by metaprogramming as well. Here, we iterate over all (binary) operators that we want to define in another for-loop:","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"for op = (:+, :*, :-, :div, :mod)\n    for type = ((:MyInt, :MyInt), (:MyInt, :Integer), (:Integer, :MyInt))\n        eval(quote\n            function Base.$op(a::$(type[1]), b::$(type[2]))\n                MyInt(Base.$op(extractValue(a), extractValue(b)))\n            end\n        end)\n    end\nend","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"Similarly, we can implement all essential integer functionality described in the Julia documentation. In our case, this includes the methods relevant to cryptographic operations, including","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"Arithmetic\nBitwise Operators\nComparison\nArray accesses\nRandomness","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"Note that with the approach outlined above, other methods can be extended even by third-party modules. See the sections on Extending the GenericLog type and Extending the Masked type for more details.","category":"page"},{"location":"types/integer-types/#int_subclass","page":"Integer Types","title":"Subclass of Integer","text":"","category":"section"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"A canonical question to ask is whether the new MyInt type should be a subtype of Integer. At first glance, this would seem like the right choice. However, establishing this subtype relationship poses some issues:","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"First, multiple dispatch only works when no ambiguities in method dispatch are present. However, if multiple arguments are passed to a function, subtyping in more than one argument may introduce ambiguities. Consider the following piece of code which runs without an error:","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"struct MyInt\n    value::Int\nend\n\nfunction Base.getindex(v::AbstractArray, i::MyInt)\n    return v[i.value]\nend\n\nv = [1, 2, 3]\ni = MyInt(2)\n\nv[i]","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"Now, consider the next block of code: The only difference to above is the declaration MyInt <: Integer:","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"struct MyInt <: Integer\n    value::Int\nend\n\nfunction Base.getindex(v::AbstractArray, i::MyInt)\n    return v[i.value]\nend\n\nv = [1, 2, 3]\ni = MyInt(2)\n\nv[i]","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"However, this second block produces an error on execution:","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"ERROR: LoadError: MethodError: getindex(::Vector{Int64}, ::MyInt) is ambiguous. Candidates:\n  getindex(v::AbstractArray, i::MyInt) in Main at [...]\n  getindex(A::Array, i1::Integer, I::Integer...) in Base at abstractarray.jl:1173\n  getindex(A::Array, i1::Union{Integer, CartesianIndex}, I::Union{Integer, CartesianIndex}...) in Base at multidimensional.jl:637\nPossible fix, define\n  getindex(::Array, ::MyInt)","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"To fix this issue, more concrete method signatures have to be defined. In the example above, since Array <: AbstractArray, we must define another method getindex(::Array, ::MyInt). However, it is not sufficient to define this single method, but a corresponding method must be defined for every subtype of AbstractArray. However, this process cannot be completed at compile-time, since new subtypes may be added dynamically. For example,  the StaticArrays package provides a type StaticArray{...} <: AbstractArray{...}. Hence, declaring our new type as a subtype of Integer requires additional method declarations that may be not even known at compile-time.","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"Another argument against subtyping the Integer is the plurality of abstract integer types: One benefit of subtyping is compatibility to code that restricts arguments to Integer types. In this code, type annotations do not need to be changed to work with this framework. However, many projects restrict function arguments to, for example, Signed or Unsigned. Thus, those types have to be manually exchanged again.","category":"page"},{"location":"types/integer-types/","page":"Integer Types","title":"Integer Types","text":"Following the two arguments outlined above, we will not use subtypes of Integer throughout this project. Instead, our type declarations will not have any specific supertype.","category":"page"},{"location":"ciphers/#Ciphers","page":"Ciphers","title":"Ciphers","text":"","category":"section"},{"location":"ciphers/#AES","page":"Ciphers","title":"AES","text":"","category":"section"},{"location":"ciphers/","page":"Ciphers","title":"Ciphers","text":"CurrentModule = CryptoSideChannel.AES","category":"page"},{"location":"ciphers/#Encryption-and-Decryption","page":"Ciphers","title":"Encryption and Decryption","text":"","category":"section"},{"location":"ciphers/","page":"Ciphers","title":"Ciphers","text":"The following two methods provide a basic interface for encrypting and decrypting. Both methods are parametrised over the underlying type for the computations.","category":"page"},{"location":"ciphers/","page":"Ciphers","title":"Ciphers","text":"For simply using AES, one would instantiate T as UInt8. For more advanced settings that log traces or use masking, refer to the respective chapters.","category":"page"},{"location":"ciphers/","page":"Ciphers","title":"Ciphers","text":"AES_encrypt\nAES_decrypt","category":"page"},{"location":"ciphers/#CryptoSideChannel.AES.AES_encrypt","page":"Ciphers","title":"CryptoSideChannel.AES.AES_encrypt","text":"AES_encrypt(plaintext::MVector{16,T}, key::Vector{T})::MVector{16,T} where T\n\nEncrypt a block of 16 bytes with AES.\n\nT must behave similarly to UInt8. For instantiating T with logging or protecting types, see the article on Integer Types.\n\nArguments\n\nplaintext must be a mutable, statically sized Vector of length 16. It contains the text to encrypt.\nkey is a vector containing the key used for the encryption. It must be either of length 16, 24, or 32.   Depending on its length, different variants of AES are dispatched:\nLength 16: AES-128\nLength 24: AES-196\nLength 32: AES-256\n\nReturns\n\nA MVector{16,T} containing the 16-byte long encrypted block.\n\n\n\n\n\n","category":"function"},{"location":"ciphers/#CryptoSideChannel.AES.AES_decrypt","page":"Ciphers","title":"CryptoSideChannel.AES.AES_decrypt","text":"AES_decrypt(ciphertext::MVector{16,T}, key::Vector{T})::MVector{16,T} where T\n\nDecrypt a block of 16 bytes with AES.\n\nT must behave similarly to UInt8. For instantiating T with logging or protecting types, see the article on Integer Types.\n\nArguments\n\nciphertext must be a mutable, statically sized Vector of length 16. It contains the data to decrypt.\nkey is a vector containing the key used for the decryption. It must be either of length 16, 24, or 32.   Depending on its length, different variants of AES are dispatched:\nLength 16: AES-128\nLength 24: AES-196\nLength 32: AES-256\n\nReturns\n\nA MVector{16,T} containing the 16-byte long decrypted block.\n\n\n\n\n\n","category":"function"},{"location":"ciphers/","page":"Ciphers","title":"Ciphers","text":"This module also exports methods to en-/decrypt data given as a hexadecimal string:","category":"page"},{"location":"ciphers/","page":"Ciphers","title":"Ciphers","text":"AES_encrypt_hex\nAES_decrypt_hex","category":"page"},{"location":"ciphers/#CryptoSideChannel.AES.AES_encrypt_hex","page":"Ciphers","title":"CryptoSideChannel.AES.AES_encrypt_hex","text":"AES_encrypt_hex(plaintext::String, key::String)\n\nInterpret plaintext and key in hexadecimal. Return a string containing the hexadecimal encrypted block. See AES_encrypt for more details.\n\nExample\n\njulia> AES_encrypt_hex(\"00112233445566778899aabbccddeeff\", \"000102030405060708090a0b0c0d0e0f\")\n\"69c4e0d86a7b0430d8cdb78070b4c55a\"\n\n\n\n\n\n","category":"function"},{"location":"ciphers/#CryptoSideChannel.AES.AES_decrypt_hex","page":"Ciphers","title":"CryptoSideChannel.AES.AES_decrypt_hex","text":"AES_decrypt_hex(ciphertext::String, key::String)\n\nInterpret ciphertext and key in hexadecimal. Return a string containing the hexadecimal decrypted block. See AES_decrypt for more details.\n\nExample\n\njulia> AES_decrypt_hex(\"69c4e0d86a7b0430d8cdb78070b4c55a\", \"000102030405060708090a0b0c0d0e0f\")\n\"00112233445566778899aabbccddeeff\"\n\n\n\n\n\n","category":"function"},{"location":"ciphers/#AES-Internal-Functions","page":"Ciphers","title":"AES Internal Functions","text":"","category":"section"},{"location":"ciphers/","page":"Ciphers","title":"Ciphers","text":"AES.key_expand\nAES.inv_key_expand","category":"page"},{"location":"ciphers/#CryptoSideChannel.AES.key_expand","page":"Ciphers","title":"CryptoSideChannel.AES.key_expand","text":"key_expand(k::Vector{T})::Vector{T}\n\nCompute the AES key schedule\n\nArguments\n\nk is the key for the AES algorithm. It should be a vector of type T, which must be an UInt8-like type.   The key is required to be a valid key for AES-128, AES-196, or AES-256. Hence, k must be either 16, 24, or 32 bytes long.\n\nReturns\n\nAn vector of type T containing the whole key schedule.\n\n\n\n\n\n","category":"function"},{"location":"ciphers/#CryptoSideChannel.AES.inv_key_expand","page":"Ciphers","title":"CryptoSideChannel.AES.inv_key_expand","text":"inv_key_expand(k::Vector{T})\n\nCompute the AES key schedule given only the last round key. This is useful for attacks targeting the last round key, or for computing the decryption key on-the-fly.\n\nwarning: Warning\nThis algorithm is currently only implemented for AES-128.\n\nArguments\n\nk is the last round key used in the AES algorithm. It should be a vector of type T, which must be an UInt8-like type.   The key is required to be a valid round key for AES. Hence, k must be exactly 16 bytes long.\n\nReturns\n\nAn vector of type T containing the whole key schedule. Most importantly, the first 16 bytes of this vector are the original AES-128 key.\n\nExample\n\njulia> key = hex2bytes(\"000102030405060708090a0b0c0d0e0f\")\njulia> last_round_key = AES.key_expand(key)[end-15:end]\njulia> recovered_key = AES.inv_key_expand(last_round_key)[1:16]\njulia> bytes2hex(recovered_key)\n\"000102030405060708090a0b0c0d0e0f\"\n\n\n\n\n\n","category":"function"},{"location":"ciphers/","page":"Ciphers","title":"Ciphers","text":"If multiple encryptions are performed with the same key, it is efficient to only compute the key schedule once. The key schedule can be computed with key_expand manually. Afterwards, the following two functions can be used for en-/decrypting data with AES with the already computed schedule:","category":"page"},{"location":"ciphers/","page":"Ciphers","title":"Ciphers","text":"AES.AES_encrypt_expanded\nAES.AES_decrypt_expanded","category":"page"},{"location":"ciphers/#CryptoSideChannel.AES.AES_encrypt_expanded","page":"Ciphers","title":"CryptoSideChannel.AES.AES_encrypt_expanded","text":"AES_encrypt_expanded(plaintext::MVector{16,T}, key::Vector{T})::MVector{16,T} where T\n\nEncrypt a block of 16 bytes with AES, given an already expanded key schedule\n\nArguments\n\nplaintext must be a mutable, statically sized Vector of length 16. It contains the text to encrypt.\nkey_schedule is a vector containing all round keys for the encryption. This vector can be obtained with the function key_expand. Based on the length of this vector, the different versions of AES are dispatched.\n\nReturns\n\nA MVector{16,T} containing the 16-byte long encrypted block.\n\n\n\n\n\n","category":"function"},{"location":"ciphers/#CryptoSideChannel.AES.AES_decrypt_expanded","page":"Ciphers","title":"CryptoSideChannel.AES.AES_decrypt_expanded","text":"AES_decrypt_expanded(ciphertext::MVector{16,T}, key::Vector{T})::MVector{16,T} where T\n\nDecrypt a block of 16 bytes with AES, given an already expanded key schedule.\n\nArguments\n\nplaintext must be a mutable, statically sized Vector of length 16. It contains the text to decrypt.\nkey_schedule is a vector containing all round keys for the decryption. This vector can be obtained with the function key_expand. Based on the length of this vector, the different versions of AES are dispatched.\n\nReturns\n\nA MVector{16,T} containing the 16-byte long decrypted block.\n\n\n\n\n\n","category":"function"},{"location":"ciphers/#SPECK","page":"Ciphers","title":"SPECK","text":"","category":"section"},{"location":"ciphers/","page":"Ciphers","title":"Ciphers","text":"CurrentModule = CryptoSideChannel.SPECK","category":"page"},{"location":"ciphers/#Encryption-and-Decryption-2","page":"Ciphers","title":"Encryption and Decryption","text":"","category":"section"},{"location":"ciphers/","page":"Ciphers","title":"Ciphers","text":"SPECK.SPECK_encrypt\nSPECK.SPECK_decrypt","category":"page"},{"location":"ciphers/#CryptoSideChannel.SPECK.SPECK_encrypt","page":"Ciphers","title":"CryptoSideChannel.SPECK.SPECK_encrypt","text":"SPECK_encrypt(plaintext::Tuple{T, T}, key::Tuple{T, T}; rounds = 32)::Tuple{T,T} where T\n\nEncrypt plaintext using key with SPECK.\n\nArguments\n\nplaintext is 128-bit data, split into two shares of type T. Each share should contain 64 bits of the plaintext. T can be either UInt64 or a similar custom integer type.\nkey is the 128-bit key, split into two shares of type T. Each share should contain 64 bits of the plaintext. T can be either UInt64 or a similar custom integer type.\nrounds is the number of rounds to execute. Defaults to 32, since this is the number of rounds mentioned in the original specification of SPECK.\n\nReturns\n\nA Tuple{T,T} containing the 128-bit encrypted data in two shares of 64 bit.\n\nnote: Note\nT can be a custom integer type, but note that T must behave like UInt64. This includes truncating overflows in additions at 64 bit.\n\nExample\n\nThe example is a SPECK128 test vector from the original SPECK paper\n\njulia> key = (0x0f0e0d0c0b0a0908, 0x0706050403020100)\njulia> plaintext = (0x6c61766975716520, 0x7469206564616d20)\njulia> SPECK.SPECK_encrypt(plaintext, key)\n(0xa65d985179783265, 0x7860fedf5c570d18)\n\n\n\n\n\n\n\n","category":"function"},{"location":"ciphers/#CryptoSideChannel.SPECK.SPECK_decrypt","page":"Ciphers","title":"CryptoSideChannel.SPECK.SPECK_decrypt","text":"SPECK_decrypt(ciphertext::Tuple{T, T}, key::Tuple{T, T}; rounds = 32)::Tuple{T,T} where T\n\nDecrypt ciphertext using key with SPECK.\n\nArguments\n\nciphertext is 128-bit data, split into two shares of type T. Each share should contain 64 bits of the plaintext. T can be either UInt64 or a similar custom integer type.\nkey is the 128-bit key, split into two shares of type T. Each share should contain 64 bits of the plaintext. T can be either UInt64 or a similar custom integer type.\nrounds is the number of rounds to execute. Defaults to 32, since this is the number of rounds mentioned in the original specification of SPECK.\n\nReturns\n\nA Tuple{T,T} containing the 128-bit encrypted data in two shares of 64 bit.\n\nnote: Note\nT can be a custom integer type, but note that T must behave like UInt64. This includes truncating overflows in additions at 64 bit.\n\nExample\n\nThe example is a SPECK128 test vector from the original SPECK paper\n\njulia> key = (0x0f0e0d0c0b0a0908, 0x0706050403020100)\njulia> plaintext = (0x6c61766975716520, 0x7469206564616d20)\njulia> SPECK.SPECK_decrypt(ciphertext, key)\n(0x6c61766975716520, 0x7469206564616d20)\n\n\n\n\n\n\n\n","category":"function"},{"location":"ciphers/#Internal-Functions","page":"Ciphers","title":"Internal Functions","text":"","category":"section"},{"location":"ciphers/","page":"Ciphers","title":"Ciphers","text":"SPECK.SPECK_key_expand\nSPECK.SPECK_encrypt_expanded\nSPECK.SPECK_decrypt_expanded","category":"page"},{"location":"ciphers/#CryptoSideChannel.SPECK.SPECK_key_expand","page":"Ciphers","title":"CryptoSideChannel.SPECK.SPECK_key_expand","text":"SPECK_key_expand(key::Tuple{T, T}, rounds)::Vector{T} where T\n\nExpand the key according to the SPECK key schedule. The result is a vector of length rounds, containing each round key. The first round key is the second component of key.\n\n\n\n\n\n","category":"function"},{"location":"ciphers/#CryptoSideChannel.SPECK.SPECK_encrypt_expanded","page":"Ciphers","title":"CryptoSideChannel.SPECK.SPECK_encrypt_expanded","text":"SPECK_encrypt_expanded(pt::Tuple{T, T}, key_schedule::Vector{T}})::Tuple{T,T} where T\n\nEncrypts data with SPECK, given an already expanded key schedule. This schedule can be created with the function SPECK_key_expand.\n\n\n\n\n\n","category":"function"},{"location":"ciphers/#CryptoSideChannel.SPECK.SPECK_decrypt_expanded","page":"Ciphers","title":"CryptoSideChannel.SPECK.SPECK_decrypt_expanded","text":"SPECK_decrypt_expanded(ct::Tuple{T, T}, key_schedule::Vector{T})::Tuple{T,T} where T\n\nDecrypts data with SPECK, given an already expanded key schedule. This schedule can be created with the function SPECK_key_expand.\n\n\n\n\n\n","category":"function"}]
}
