<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ciphers · CryptoSideChannel.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CryptoSideChannel.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Ciphers</a><ul class="internal"><li><a class="tocitem" href="#AES"><span>AES</span></a></li><li><a class="tocitem" href="#SPECK"><span>SPECK</span></a></li></ul></li><li><span class="tocitem">Types</span><ul><li><a class="tocitem" href="../types/integer-types/">Integer Types</a></li><li><a class="tocitem" href="../types/logging/">Logging</a></li><li><a class="tocitem" href="../types/masking/">Masking</a></li><li><a class="tocitem" href="../types/create-traces/">Create your own traces</a></li></ul></li><li><span class="tocitem">Attacks</span><ul><li><a class="tocitem" href="../attacks/dpa/">DPA</a></li><li><a class="tocitem" href="../attacks/cpa/">CPA</a></li><li><a class="tocitem" href="../attacks/template/">Template</a></li><li><a class="tocitem" href="../attacks/keycombination/">Key combination</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Ciphers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Ciphers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/parablack/CryptoSideChannel.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Ciphers"><a class="docs-heading-anchor" href="#Ciphers">Ciphers</a><a id="Ciphers-1"></a><a class="docs-heading-anchor-permalink" href="#Ciphers" title="Permalink"></a></h1><h2 id="AES"><a class="docs-heading-anchor" href="#AES">AES</a><a id="AES-1"></a><a class="docs-heading-anchor-permalink" href="#AES" title="Permalink"></a></h2><h3 id="Encryption-and-Decryption"><a class="docs-heading-anchor" href="#Encryption-and-Decryption">Encryption and Decryption</a><a id="Encryption-and-Decryption-1"></a><a class="docs-heading-anchor-permalink" href="#Encryption-and-Decryption" title="Permalink"></a></h3><p>The following two methods provide a basic interface for encrypting and decrypting. Both methods are parametrised over the underlying type for the computations.</p><p>For simply using AES, one would instantiate <code>T</code> as <code>UInt8</code>. For more advanced settings that log traces or use masking, refer to the respective chapters.</p><article class="docstring"><header><a class="docstring-binding" id="CryptoSideChannel.AES.AES_encrypt" href="#CryptoSideChannel.AES.AES_encrypt"><code>CryptoSideChannel.AES.AES_encrypt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">AES_encrypt(plaintext::MVector{16,T}, key::Vector{T})::MVector{16,T} where T</code></pre><p>Encrypt a block of 16 bytes with AES.</p><p><code>T</code> must behave similarly to <code>UInt8</code>. For instantiating <code>T</code> with logging or protecting types, see the article on <a href="../types/integer-types/#integer_types">Integer Types</a>.</p><p><strong>Arguments</strong></p><ul><li><code>plaintext</code> must be a mutable, statically sized Vector of length 16. It contains the text to encrypt.</li><li><code>key</code> is a vector containing the key used for the encryption. It must be either of length 16, 24, or 32.   Depending on its length, different variants of AES are dispatched:<ul><li>Length 16: AES-128</li><li>Length 24: AES-196</li><li>Length 32: AES-256</li></ul></li></ul><p><strong>Returns</strong></p><p>A <code>MVector{16,T}</code> containing the 16-byte long encrypted block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/parablack/CryptoSideChannel.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryptoSideChannel.AES.AES_decrypt" href="#CryptoSideChannel.AES.AES_decrypt"><code>CryptoSideChannel.AES.AES_decrypt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">AES_decrypt(ciphertext::MVector{16,T}, key::Vector{T})::MVector{16,T} where T</code></pre><p>Decrypt a block of 16 bytes with AES.</p><p><code>T</code> must behave similarly to <code>UInt8</code>. For instantiating <code>T</code> with logging or protecting types, see the article on <a href="../types/integer-types/#integer_types">Integer Types</a>.</p><p><strong>Arguments</strong></p><ul><li><code>ciphertext</code> must be a mutable, statically sized Vector of length 16. It contains the data to decrypt.</li><li><code>key</code> is a vector containing the key used for the decryption. It must be either of length 16, 24, or 32.   Depending on its length, different variants of AES are dispatched:<ul><li>Length 16: AES-128</li><li>Length 24: AES-196</li><li>Length 32: AES-256</li></ul></li></ul><p><strong>Returns</strong></p><p>A <code>MVector{16,T}</code> containing the 16-byte long decrypted block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/parablack/CryptoSideChannel.jl">source</a></section></article><p>This module also exports methods to en-/decrypt data given as a hexadecimal string:</p><article class="docstring"><header><a class="docstring-binding" id="CryptoSideChannel.AES.AES_encrypt_hex" href="#CryptoSideChannel.AES.AES_encrypt_hex"><code>CryptoSideChannel.AES.AES_encrypt_hex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">AES_encrypt_hex(plaintext::String, key::String)</code></pre><p>Interpret <code>plaintext</code> and <code>key</code> in hexadecimal. Return a string containing the hexadecimal encrypted block. See <a href="#CryptoSideChannel.AES.AES_encrypt"><code>AES_encrypt</code></a> for more details.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; AES_encrypt_hex(&quot;00112233445566778899aabbccddeeff&quot;, &quot;000102030405060708090a0b0c0d0e0f&quot;)
&quot;69c4e0d86a7b0430d8cdb78070b4c55a&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/parablack/CryptoSideChannel.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryptoSideChannel.AES.AES_decrypt_hex" href="#CryptoSideChannel.AES.AES_decrypt_hex"><code>CryptoSideChannel.AES.AES_decrypt_hex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">AES_decrypt_hex(ciphertext::String, key::String)</code></pre><p>Interpret <code>ciphertext</code> and <code>key</code> in hexadecimal. Return a string containing the hexadecimal decrypted block. See <a href="#CryptoSideChannel.AES.AES_decrypt"><code>AES_decrypt</code></a> for more details.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; AES_decrypt_hex(&quot;69c4e0d86a7b0430d8cdb78070b4c55a&quot;, &quot;000102030405060708090a0b0c0d0e0f&quot;)
&quot;00112233445566778899aabbccddeeff&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/parablack/CryptoSideChannel.jl">source</a></section></article><h3 id="AES-Internal-Functions"><a class="docs-heading-anchor" href="#AES-Internal-Functions">AES Internal Functions</a><a id="AES-Internal-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#AES-Internal-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CryptoSideChannel.AES.key_expand" href="#CryptoSideChannel.AES.key_expand"><code>CryptoSideChannel.AES.key_expand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">key_expand(k::Vector{T})::Vector{T}</code></pre><p>Compute the <a href="https://en.wikipedia.org/wiki/AES_key_schedule">AES key schedule</a></p><p><strong>Arguments</strong></p><ul><li><code>k</code> is the key for the AES algorithm. It should be a vector of type T, which must be an UInt8-like type.   The key is required to be a valid key for AES-128, AES-196, or AES-256. Hence, <code>k</code> must be either 16, 24, or 32 bytes long.</li></ul><p><strong>Returns</strong></p><p>An vector of type T containing the whole key schedule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/parablack/CryptoSideChannel.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryptoSideChannel.AES.inv_key_expand" href="#CryptoSideChannel.AES.inv_key_expand"><code>CryptoSideChannel.AES.inv_key_expand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">inv_key_expand(k::Vector{T})</code></pre><p>Compute the <a href="https://en.wikipedia.org/wiki/AES_key_schedule">AES key schedule</a> given only the <strong>last round key</strong>. This is useful for attacks targeting the last round key, or for computing the decryption key on-the-fly.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This algorithm is currently only implemented for AES-128.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>k</code> is the last round key used in the AES algorithm. It should be a vector of type T, which must be an UInt8-like type.   The key is required to be a valid round key for AES. Hence, <code>k</code> must be exactly 16 bytes long.</li></ul><p><strong>Returns</strong></p><p>An vector of type T containing the whole key schedule. Most importantly, the first 16 bytes of this vector are the original AES-128 key.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; key = hex2bytes(&quot;000102030405060708090a0b0c0d0e0f&quot;)
julia&gt; last_round_key = AES.key_expand(key)[end-15:end]
julia&gt; recovered_key = AES.inv_key_expand(last_round_key)[1:16]
julia&gt; bytes2hex(recovered_key)
&quot;000102030405060708090a0b0c0d0e0f&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/parablack/CryptoSideChannel.jl">source</a></section></article><p>If multiple encryptions are performed with the same key, it is efficient to only compute the key schedule once. The key schedule can be computed with <code>key_expand</code> manually. Afterwards, the following two functions can be used for en-/decrypting data with AES with the already computed schedule:</p><article class="docstring"><header><a class="docstring-binding" id="CryptoSideChannel.AES.AES_encrypt_expanded" href="#CryptoSideChannel.AES.AES_encrypt_expanded"><code>CryptoSideChannel.AES.AES_encrypt_expanded</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">AES_encrypt_expanded(plaintext::MVector{16,T}, key::Vector{T})::MVector{16,T} where T</code></pre><p>Encrypt a block of 16 bytes with AES, given an already expanded key schedule</p><p><strong>Arguments</strong></p><ul><li><code>plaintext</code> must be a mutable, statically sized Vector of length 16. It contains the text to encrypt.</li><li><code>key_schedule</code> is a vector containing all round keys for the encryption. This vector can be obtained with the function <code>key_expand</code>. Based on the length of this vector, the different versions of AES are dispatched.</li></ul><p><strong>Returns</strong></p><p>A <code>MVector{16,T}</code> containing the 16-byte long encrypted block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/parablack/CryptoSideChannel.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryptoSideChannel.AES.AES_decrypt_expanded" href="#CryptoSideChannel.AES.AES_decrypt_expanded"><code>CryptoSideChannel.AES.AES_decrypt_expanded</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">AES_decrypt_expanded(ciphertext::MVector{16,T}, key::Vector{T})::MVector{16,T} where T</code></pre><p>Decrypt a block of 16 bytes with AES, given an already expanded key schedule.</p><p><strong>Arguments</strong></p><ul><li><code>plaintext</code> must be a mutable, statically sized Vector of length 16. It contains the text to decrypt.</li><li><code>key_schedule</code> is a vector containing all round keys for the decryption. This vector can be obtained with the function <code>key_expand</code>. Based on the length of this vector, the different versions of AES are dispatched.</li></ul><p><strong>Returns</strong></p><p>A <code>MVector{16,T}</code> containing the 16-byte long decrypted block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/parablack/CryptoSideChannel.jl">source</a></section></article><h2 id="SPECK"><a class="docs-heading-anchor" href="#SPECK">SPECK</a><a id="SPECK-1"></a><a class="docs-heading-anchor-permalink" href="#SPECK" title="Permalink"></a></h2><h3 id="Encryption-and-Decryption-2"><a class="docs-heading-anchor" href="#Encryption-and-Decryption-2">Encryption and Decryption</a><a class="docs-heading-anchor-permalink" href="#Encryption-and-Decryption-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CryptoSideChannel.SPECK.SPECK_encrypt" href="#CryptoSideChannel.SPECK.SPECK_encrypt"><code>CryptoSideChannel.SPECK.SPECK_encrypt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SPECK_encrypt(plaintext::Tuple{T, T}, key::Tuple{T, T}; rounds = 32)::Tuple{T,T} where T</code></pre><p>Encrypt <code>plaintext</code> using <code>key</code> with SPECK.</p><p><strong>Arguments</strong></p><ul><li><code>plaintext</code> is 128-bit data, split into two shares of type <code>T</code>. Each share should contain 64 bits of the plaintext. <code>T</code> can be either <code>UInt64</code> or a similar <a href="../types/integer-types/#integer_types">custom integer</a> type.</li><li><code>key</code> is the 128-bit key, split into two shares of type <code>T</code>. Each share should contain 64 bits of the plaintext. <code>T</code> can be either <code>UInt64</code> or a similar <a href="../types/integer-types/#integer_types">custom integer</a> type.</li><li><code>rounds</code> is the number of rounds to execute. Defaults to <code>32</code>, since this is the number of rounds mentioned in the original specification of SPECK.</li></ul><p><strong>Returns</strong></p><p>A <code>Tuple{T,T}</code> containing the 128-bit encrypted data in two shares of 64 bit.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>T can be a custom integer type, but note that <code>T</code> <em>must</em> behave like <code>UInt64</code>. This includes truncating overflows in additions at 64 bit.</p></div></div><p><strong>Example</strong></p><p>The example is a SPECK128 test vector from <a href="https://eprint.iacr.org/2013/404.pdf">the original SPECK paper</a></p><pre><code class="language-julia-repl">julia&gt; key = (0x0f0e0d0c0b0a0908, 0x0706050403020100)
julia&gt; plaintext = (0x6c61766975716520, 0x7469206564616d20)
julia&gt; SPECK.SPECK_encrypt(plaintext, key)
(0xa65d985179783265, 0x7860fedf5c570d18)</code></pre><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/parablack/CryptoSideChannel.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryptoSideChannel.SPECK.SPECK_decrypt" href="#CryptoSideChannel.SPECK.SPECK_decrypt"><code>CryptoSideChannel.SPECK.SPECK_decrypt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SPECK_decrypt(ciphertext::Tuple{T, T}, key::Tuple{T, T}; rounds = 32)::Tuple{T,T} where T</code></pre><p>Decrypt <code>ciphertext</code> using <code>key</code> with SPECK.</p><p><strong>Arguments</strong></p><ul><li><code>ciphertext</code> is 128-bit data, split into two shares of type <code>T</code>. Each share should contain 64 bits of the plaintext. <code>T</code> can be either <code>UInt64</code> or a similar <a href="../types/integer-types/#integer_types">custom integer</a> type.</li><li><code>key</code> is the 128-bit key, split into two shares of type <code>T</code>. Each share should contain 64 bits of the plaintext. <code>T</code> can be either <code>UInt64</code> or a similar <a href="../types/integer-types/#integer_types">custom integer</a> type.</li><li><code>rounds</code> is the number of rounds to execute. Defaults to <code>32</code>, since this is the number of rounds mentioned in the original specification of SPECK.</li></ul><p><strong>Returns</strong></p><p>A <code>Tuple{T,T}</code> containing the 128-bit encrypted data in two shares of 64 bit.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>T can be a custom integer type, but note that <code>T</code> <em>must</em> behave like <code>UInt64</code>. This includes truncating overflows in additions at 64 bit.</p></div></div><p><strong>Example</strong></p><p>The example is a SPECK128 test vector from <a href="https://eprint.iacr.org/2013/404.pdf">the original SPECK paper</a></p><pre><code class="language-julia-repl">julia&gt; key = (0x0f0e0d0c0b0a0908, 0x0706050403020100)
julia&gt; plaintext = (0x6c61766975716520, 0x7469206564616d20)
julia&gt; SPECK.SPECK_decrypt(ciphertext, key)
(0x6c61766975716520, 0x7469206564616d20)</code></pre><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/parablack/CryptoSideChannel.jl">source</a></section></article><h3 id="Internal-Functions"><a class="docs-heading-anchor" href="#Internal-Functions">Internal Functions</a><a id="Internal-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CryptoSideChannel.SPECK.SPECK_key_expand" href="#CryptoSideChannel.SPECK.SPECK_key_expand"><code>CryptoSideChannel.SPECK.SPECK_key_expand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SPECK_key_expand(key::Tuple{T, T}, rounds)::Vector{T} where T</code></pre><p>Expand the key according to the SPECK key schedule. The result is a vector of length <code>rounds</code>, containing each round key. The first round key is the second component of <code>key</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/parablack/CryptoSideChannel.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryptoSideChannel.SPECK.SPECK_encrypt_expanded" href="#CryptoSideChannel.SPECK.SPECK_encrypt_expanded"><code>CryptoSideChannel.SPECK.SPECK_encrypt_expanded</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SPECK_encrypt_expanded(pt::Tuple{T, T}, key_schedule::Vector{T}})::Tuple{T,T} where T</code></pre><p>Encrypts data with SPECK, given an already expanded key schedule. This schedule can be created with the function <code>SPECK_key_expand</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/parablack/CryptoSideChannel.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CryptoSideChannel.SPECK.SPECK_decrypt_expanded" href="#CryptoSideChannel.SPECK.SPECK_decrypt_expanded"><code>CryptoSideChannel.SPECK.SPECK_decrypt_expanded</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SPECK_decrypt_expanded(ct::Tuple{T, T}, key_schedule::Vector{T})::Tuple{T,T} where T</code></pre><p>Decrypts data with SPECK, given an already expanded key schedule. This schedule can be created with the function <code>SPECK_key_expand</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/parablack/CryptoSideChannel.jl">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../types/integer-types/">Integer Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 31 May 2021 21:23">Monday 31 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
