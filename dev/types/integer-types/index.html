<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Integer Types · CryptoSideChannel.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CryptoSideChannel.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../ciphers/">Ciphers</a></li><li><span class="tocitem">Types</span><ul><li class="is-active"><a class="tocitem" href>Integer Types</a><ul class="internal"><li><a class="tocitem" href="#Custom-Integer-Types"><span>Custom Integer Types</span></a></li><li><a class="tocitem" href="#int_subclass"><span>Subclass of <code>Integer</code></span></a></li></ul></li><li><a class="tocitem" href="../logging/">Logging</a></li><li><a class="tocitem" href="../masking/">Masking</a></li><li><a class="tocitem" href="../create-traces/">Create your own traces</a></li></ul></li><li><span class="tocitem">Attacks</span><ul><li><a class="tocitem" href="../../attacks/dpa/">DPA</a></li><li><a class="tocitem" href="../../attacks/cpa/">CPA</a></li><li><a class="tocitem" href="../../attacks/template/">Template</a></li><li><a class="tocitem" href="../../attacks/keycombination/">Key combination</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Types</a></li><li class="is-active"><a href>Integer Types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Integer Types</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/parablack/CryptoSideChannel.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="integer_types"><a class="docs-heading-anchor" href="#integer_types">Integer Types</a><a id="integer_types-1"></a><a class="docs-heading-anchor-permalink" href="#integer_types" title="Permalink"></a></h1><p>By default, Julia ships with an abstract <a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Integer"><code>Integer</code></a> type, which shall be the supertype for all integers.</p><p>Furthermore, Julia&#39;s base comes with <a href="https://docs.julialang.org/en/v1/manual/types/#Primitive-Types">primitive Integer types</a> like <code>Int8</code>, <code>UInt8</code>, <code>Int64</code>, <code>UInt64</code>. Note that <code>Int == Int64</code> on 64-bit systems. Hence, <code>Int</code> is a primitive type as well.</p><p>Eventually, computations are executed on primitive Integer types, while methods are often dispatched on the abstract <code>Integer</code> datatype. For this to work, it is crucial that the primitive types are subtypes of the abstract <code>Integer</code> type, which can be confirmed easily:</p><pre><code class="language-julia-repl">julia&gt; UInt8 &lt;: Integer
true
julia&gt; Int64 &lt;: Integer
true</code></pre><h2 id="Custom-Integer-Types"><a class="docs-heading-anchor" href="#Custom-Integer-Types">Custom Integer Types</a><a id="Custom-Integer-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Integer-Types" title="Permalink"></a></h2><p>An important goal of this library is to provide new types that <em>behave similarly</em> to integers, but include custom functionality. Those types are constructed using a <a href="https://en.wikipedia.org/wiki/Duck_typing">duck typing</a> approach:</p><blockquote><p>If it walks like a duck and it quacks like a duck, then it must be a duck</p></blockquote><p>Thus, our newly created types will not be a subtype of <code>Integer</code>, but instead only <em>behave</em> like integers in certain contexts. A detailed discussion on this choice can be found in <a href="#int_subclass">this section</a>.</p><p>Technically, a definition of a very simple custom integer type could look as follows:</p><pre><code class="language-julia">struct MyInt
    value::Int
end</code></pre><p>Now, using Julia&#39;s powerful multiple dispatch functionality, we can start defining methods on our custom integer. For example, addition could be defined in the following way:</p><pre><code class="language-julia">function Base.:(+)(a::MyInt, b::MyInt)
    # custom code (if desired) here
    MyInt(a.value + b.value)
end</code></pre><p>Since we want our type to be compatible with normal integers, it is also necessary to define the following two procedures:</p><pre><code class="language-julia">function Base.:(+)(a::MyInt, b::Integer)
    # custom code (if desired) here
    MyInt(a.value + b)
end
function Base.:(+)(a::Integer, b::MyInt)
    # custom code (if desired) here
    MyInt(a + b.value)
end</code></pre><p>Extending this to other operators is, of course, extremely tedious and results in large code duplicates. This can be avoided by the use of metaprogramming to generate those functions. Consider the following function definitions instead:</p><pre><code class="language-julia">extractValue(a::MyInt) = a.value
extractValue(a::Integer) = a

function Base.:(+)(a::MyInt, b::MyInt)
    MyInt(extractValue(a) + extractValue(b))
end
function Base.:(+)(a::MyInt, b::Integer)
    MyInt(extractValue(a) + extractValue(b))
end
function Base.:(+)(a::Integer, b::MyInt)
    MyInt(extractValue(a) + extractValue(b))
end</code></pre><p>Now, all three procedures have the exact same body. Hence, we can subsume all three procedures by using Julia&#39;s metaprogramming:</p><pre><code class="language-julia">for type = ((:MyInt, :MyInt), (:MyInt, :Integer), (:Integer, :MyInt))
    eval(quote
        function Base.:(+)(a::$(type[1]), b::$(type[2]))
            # custom code here
            MyInt(extractValue(a) + extractValue(b))
        end
    end)
end</code></pre><p>Here, the outer <code>for</code>-loop is evaluated at compile time. Thus, three new methods are registered by evaluating the generated function body.</p><p>Of course, we like to extend this construction to other operators. We can achieve this by metaprogramming as well. Here, we iterate over all (binary) operators that we want to define in another <code>for</code>-loop:</p><pre><code class="language-julia">for op = (:+, :*, :-, :div, :mod)
    for type = ((:MyInt, :MyInt), (:MyInt, :Integer), (:Integer, :MyInt))
        eval(quote
            function Base.$op(a::$(type[1]), b::$(type[2]))
                MyInt(Base.$op(extractValue(a), extractValue(b)))
            end
        end)
    end
end</code></pre><p>Similarly, we can implement all essential integer functionality described in <a href="https://docs.julialang.org/en/v1/manual/mathematical-operations/">the Julia documentation</a>. In our case, this includes the methods relevant to cryptographic operations, including</p><ul><li>Arithmetic</li><li>Bitwise Operators</li><li>Comparison</li><li>Array accesses</li><li>Randomness</li></ul><p>Note that with the approach outlined above, other methods can be extended even by third-party modules. See the sections on <a href="../logging/#extending_log_funs">Extending the <code>GenericLog</code> type</a> and <a href="../masking/#extending_masking_funs">Extending the <code>Masked</code> type</a> for more details.</p><h2 id="int_subclass"><a class="docs-heading-anchor" href="#int_subclass">Subclass of <code>Integer</code></a><a id="int_subclass-1"></a><a class="docs-heading-anchor-permalink" href="#int_subclass" title="Permalink"></a></h2><p>A canonical question to ask is whether the new <code>MyInt</code> type should be a subtype of <code>Integer</code>. At first glance, this would seem like the right choice. However, establishing this subtype relationship poses some issues:</p><p>First, multiple dispatch only works when no ambiguities in method dispatch are present. However, if multiple arguments are passed to a function, subtyping in more than one argument may introduce ambiguities. Consider the following piece of code which runs without an error:</p><pre><code class="language-julia">struct MyInt
    value::Int
end

function Base.getindex(v::AbstractArray, i::MyInt)
    return v[i.value]
end

v = [1, 2, 3]
i = MyInt(2)

v[i]</code></pre><p>Now, consider the next block of code: The only difference to above is the declaration <code>MyInt &lt;: Integer</code>:</p><pre><code class="language-julia">struct MyInt &lt;: Integer
    value::Int
end

function Base.getindex(v::AbstractArray, i::MyInt)
    return v[i.value]
end

v = [1, 2, 3]
i = MyInt(2)

v[i]</code></pre><p>However, this second block produces an error on execution:</p><pre><code class="language-none">ERROR: LoadError: MethodError: getindex(::Vector{Int64}, ::MyInt) is ambiguous. Candidates:
  getindex(v::AbstractArray, i::MyInt) in Main at [...]
  getindex(A::Array, i1::Integer, I::Integer...) in Base at abstractarray.jl:1173
  getindex(A::Array, i1::Union{Integer, CartesianIndex}, I::Union{Integer, CartesianIndex}...) in Base at multidimensional.jl:637
Possible fix, define
  getindex(::Array, ::MyInt)</code></pre><p>To fix this issue, more concrete method signatures have to be defined. In the example above, since <code>Array &lt;: AbstractArray</code>, we must define another method <code>getindex(::Array, ::MyInt)</code>. However, it is not sufficient to define this single method, but a corresponding method must be defined for every subtype of <code>AbstractArray</code>. However, this process cannot be completed at compile-time, since new subtypes may be added dynamically. For example,  the <code>StaticArrays</code> package provides a type <code>StaticArray{...} &lt;: AbstractArray{...}</code>. Hence, declaring our new type as a subtype of <code>Integer</code> requires additional method declarations that may be not even known at compile-time.</p><p>Another argument against subtyping the <code>Integer</code> is the plurality of abstract integer types: One benefit of subtyping is compatibility to code that restricts arguments to <code>Integer</code> types. In this code, type annotations do not need to be changed to work with this framework. However, many projects restrict function arguments to, for example, <code>Signed</code> or <code>Unsigned</code>. Thus, those types have to be manually exchanged again.</p><p>Following the two arguments outlined above, we will not use subtypes of <code>Integer</code> throughout this project. Instead, our type declarations will not have any specific supertype.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../ciphers/">« Ciphers</a><a class="docs-footer-nextpage" href="../logging/">Logging »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 31 May 2021 21:23">Monday 31 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
